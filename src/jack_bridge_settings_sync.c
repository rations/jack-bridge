/*
 * jack_bridge_settings_sync.c
 * Settings file I/O for jack-bridge D-Bus service
 * 
 * Handles reading/writing /etc/default/jackd-rt configuration file
 * Provides atomic updates and preserves comments
 */

#include "jack_bridge_settings_sync.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <glib.h>

#define JACKD_RT_CONFIG "/etc/default/jackd-rt"
#define MAX_LINE 512

/* Configuration cache for thread-safe access */
static GHashTable *config_cache = NULL;
static GMutex config_cache_mutex;

/* Initialize mutex at startup */
GMutex *get_config_cache_mutex(void) {
    static gsize mutex_initialized = 0;
    if (g_once_init_enter(&mutex_initialized)) {
        g_mutex_init(&config_cache_mutex);
        g_once_init_leave(&mutex_initialized, 1);
    }
    return &config_cache_mutex;
}

/*
 * parse_config_file()
 * Parse /etc/default/jackd-rt into a GHashTable
 * Handles KEY=value and KEY="value" formats
 */
GHashTable *parse_config_file(const char *path) {
    GHashTable *config;
    FILE *f;
    char line[MAX_LINE];
    
    config = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
    
    f = fopen(path, "r");
    if (!f) {
        g_warning("settings_sync: Cannot open %s: %s", path, strerror(errno));
        /* Create default configuration if file doesn't exist */
        if (errno == ENOENT) {
            g_message("settings_sync: Creating default configuration file");
            FILE *default_f = fopen(path, "w");
            if (default_f) {
                fprintf(default_f, "# /etc/default/jackd-rt - JACK configuration\n");
                fprintf(default_f, "# Generated by jack-bridge D-Bus service\n\n");
                fprintf(default_f, "JACKD_SR=48000\n");
                fprintf(default_f, "JACKD_PERIOD=256\n");
                fprintf(default_f, "JACKD_NPERIODS=3\n");
                fprintf(default_f, "JACKD_DEVICE=\n");
                fprintf(default_f, "JACKD_PRIORITY=70\n");
                fprintf(default_f, "JACKD_MIDI=seq\n");
                fclose(default_f);
                g_message("settings_sync: Default configuration created");
            }
        }
        return config; /* Return empty table */
    }
    
    while (fgets(line, sizeof(line), f)) {
        char *key, *value, *eq, *end;
        
        /* Skip comments and empty lines */
        if (line[0] == '#' || line[0] == '\n' || line[0] == '\0') {
            continue;
        }
        
        /* Find '=' */
        eq = strchr(line, '=');
        if (!eq) continue;
        
        /* Extract key (before '=') */
        *eq = '\0';
        key = line;
        
        /* Trim spaces from key */
        while (*key == ' ' || *key == '\t') key++;
        end = key + strlen(key) - 1;
        while (end > key && (*end == ' ' || *end == '\t')) {
            *end = '\0';
            end--;
        }
        
        /* Extract value (after '=') */
        value = eq + 1;
        
        /* Trim leading spaces */
        while (*value == ' ' || *value == '\t') value++;
        
        /* Remove trailing newline and spaces */
        end = value + strlen(value) - 1;
        while (end >= value && (*end == '\n' || *end == '\r' || *end == ' ' || *end == '\t')) {
            *end = '\0';
            end--;
        }
        
        /* Remove quotes if present */
        if (*value == '"' || *value == '\'') {
            char quote = *value;
            value++;
            end = value + strlen(value) - 1;
            if (end >= value && *end == quote) {
                *end = '\0';
            }
        }
        
        /* Store in hash table */
        if (strlen(key) > 0) {
            g_hash_table_insert(config, g_strdup(key), g_strdup(value));
        }
    }
    
    fclose(f);
    return config;
}

/*
 * init_config_cache()
 * Initialize configuration cache at startup
 */
void init_config_cache(void) {
    GMutex *mutex = get_config_cache_mutex();
    g_mutex_lock(mutex);
    
    if (config_cache) {
        g_hash_table_destroy(config_cache);
    }
    
    config_cache = parse_config_file(JACKD_RT_CONFIG);
    g_mutex_unlock(mutex);
}

/*
 * refresh_config_cache()
 * Refresh configuration cache after external changes
 */
void refresh_config_cache(void) {
    GMutex *mutex = get_config_cache_mutex();
    g_mutex_lock(mutex);
    
    if (config_cache) {
        g_hash_table_destroy(config_cache);
    }
    
    config_cache = parse_config_file(JACKD_RT_CONFIG);
    g_mutex_unlock(mutex);
}

/*
 * get_config_value()
 * Read a configuration value from /etc/default/jackd-rt
 */
gchar *get_config_value(const char *key) {
    if (!key || strlen(key) == 0) {
        g_warning("settings_sync: get_config_value called with NULL or empty key");
        return NULL;
    }
    
    GMutex *mutex = get_config_cache_mutex();
    gchar *value = NULL;
    
    g_mutex_lock(mutex);
    
    /* Try cache first */
    if (config_cache) {
        const gchar *val = g_hash_table_lookup(config_cache, key);
        if (val) {
            value = g_strdup(val);
            g_mutex_unlock(mutex);
            g_debug("settings_sync: Cache hit for key '%s' = '%s'", key, value);
            return value;
        }
    }
    
    g_mutex_unlock(mutex);
    
    /* Fallback to direct file parsing if not in cache */
    GHashTable *config = parse_config_file(JACKD_RT_CONFIG);
    if (config) {
        const gchar *val = g_hash_table_lookup(config, key);
        if (val) {
            value = g_strdup(val);
            g_debug("settings_sync: File read for key '%s' = '%s'", key, value);
        } else {
            g_debug("settings_sync: Key '%s' not found in configuration", key);
        }
        g_hash_table_destroy(config);
    } else {
        g_warning("settings_sync: Failed to parse configuration file for key '%s'", key);
    }
    
    return value;
}

/*
 * get_config_int()
 * Read an integer configuration value
 */
gint get_config_int(const char *key, gint default_value) {
    gchar *str_val = get_config_value(key);
    gint result = default_value;
    
    if (str_val) {
        result = atoi(str_val);
        g_free(str_val);
    }
    
    return result;
}

/*
 * set_config_value()
 * Write a configuration value to /etc/default/jackd-rt atomically
 * Preserves comments and other settings
 */
gboolean set_config_value(const char *key, const char *value) {
    FILE *in, *out;
    char line[MAX_LINE];
    char tmpfile[] = "/etc/default/jackd-rt.tmp.XXXXXX";
    int fd;
    gboolean key_found = FALSE;
    
    /* Create temporary file */
    fd = mkstemp(tmpfile);
    if (fd < 0) {
        g_critical("settings_sync: Failed to create temp file: %s", strerror(errno));
        return FALSE;
    }
    
    out = fdopen(fd, "w");
    if (!out) {
        g_critical("settings_sync: Failed to open temp file: %s", strerror(errno));
        close(fd);
        unlink(tmpfile);
        return FALSE;
    }
    
    /* Open original file */
    in = fopen(JACKD_RT_CONFIG, "r");
    if (!in) {
        /* File doesn't exist, create new one */
        fprintf(out, "# /etc/default/jackd-rt - JACK configuration\n");
        fprintf(out, "# Generated by jack-bridge D-Bus service\n\n");
        fprintf(out, "%s=%s\n", key, value);
        fclose(out);
        
        if (rename(tmpfile, JACKD_RT_CONFIG) != 0) {
            g_critical("settings_sync: Failed to rename %s: %s", tmpfile, strerror(errno));
            unlink(tmpfile);
            return FALSE;
        }
        
        return TRUE;
    }
    
    /* Copy file, replacing key if found */
    while (fgets(line, sizeof(line), in)) {
        char *eq = strchr(line, '=');
        
        /* Check if this line contains our key */
        if (eq) {
            char saved_eq = *eq;
            *eq = '\0';
            
            /* Trim spaces from line key */
            char *line_key = line;
            while (*line_key == ' ' || *line_key == '\t') line_key++;
            char *end = line_key + strlen(line_key) - 1;
            while (end > line_key && (*end == ' ' || *end == '\t')) {
                *end = '\0';
                end--;
            }
            
            if (strcmp(line_key, key) == 0) {
                /* Replace this line */
                fprintf(out, "%s=%s\n", key, value);
                key_found = TRUE;
                *eq = saved_eq; /* Restore for next iteration */
                continue;
            }
            
            *eq = saved_eq; /* Restore */
        }
        
        /* Copy line as-is */
        fputs(line, out);
    }
    
    /* If key wasn't found, append it */
    if (!key_found) {
        fprintf(out, "\n# Added by jack-bridge D-Bus service\n");
        fprintf(out, "%s=%s\n", key, value);
    }
    
    fclose(in);
    fclose(out);
    
    /* Atomic rename */
    if (rename(tmpfile, JACKD_RT_CONFIG) != 0) {
        g_critical("settings_sync: Failed to rename %s to %s: %s",
                   tmpfile, JACKD_RT_CONFIG, strerror(errno));
        unlink(tmpfile);
        return FALSE;
    }
    
    
    /* Refresh cache after successful write */
    refresh_config_cache();
    
    return TRUE;
}

/*
 * set_config_int()
 * Write an integer configuration value
 */
gboolean set_config_int(const char *key, gint value) {
    gchar *str_val = g_strdup_printf("%d", value);
    gboolean result = set_config_value(key, str_val);
    g_free(str_val);
    return result;
}

/*
 * validate_sample_rate()
 * Check if sample rate is valid
 */
gboolean validate_sample_rate(guint rate) {
    switch (rate) {
        case 22050:
        case 44100:
        case 48000:
        case 88200:
        case 96000:
        case 176400:
        case 192000:
            return TRUE;
        default:
            return FALSE;
    }
}

/*
 * validate_period()
 * Check if period (frames/buffer) is valid (must be power of 2)
 */
gboolean validate_period(guint period) {
    /* Must be power of 2 between 16 and 4096 */
    if (period < 16 || period > 4096) {
        return FALSE;
    }
    
    /* Check if power of 2: (n & (n-1)) == 0 */
    return (period & (period - 1)) == 0;
}

/*
 * validate_nperiods()
 * Check if nperiods is valid (must be >= 2)
 */
gboolean validate_nperiods(guint nperiods) {
    /* Minimum 2, maximum 8 (reasonable range) */
    return (nperiods >= 2 && nperiods <= 8);
}

/*
 * validate_priority()
 * Check if realtime priority is valid
 */
gboolean validate_priority(guint priority) {
    /* 0 = disabled, 10-89 = realtime range */
    return (priority == 0 || (priority >= 10 && priority <= 89));
}

/*
 * calculate_latency_ms()
 * Calculate theoretical latency in milliseconds
 */
gdouble calculate_latency_ms(guint period, guint nperiods, guint sample_rate) {
    if (sample_rate == 0) {
        return 0.0;
    }
    
    /* Latency = (period Ã— nperiods) / sample_rate * 1000 */
    return ((gdouble)(period * nperiods) / (gdouble)sample_rate) * 1000.0;
}