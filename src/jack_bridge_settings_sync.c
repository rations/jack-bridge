/*
 * jack_bridge_settings_sync.c
 * Settings file I/O for jack-bridge D-Bus service
 * 
 * Handles reading/writing /etc/default/jackd-rt configuration file
 * Provides atomic updates and preserves comments
 */

#include "jack_bridge_settings_sync.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <glib.h>

#define JACKD_RT_CONFIG "/etc/default/jackd-rt"
#define MAX_LINE 512

/*
 * parse_config_file()
 * Parse /etc/default/jackd-rt into a GHashTable
 * Handles KEY=value and KEY="value" formats
 */
GHashTable *parse_config_file(const char *path) {
    GHashTable *config;
    FILE *f;
    char line[MAX_LINE];
    
    config = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
    
    f = fopen(path, "r");
    if (!f) {
        g_warning("settings_sync: Cannot open %s: %s", path, strerror(errno));
        return config; /* Return empty table */
    }
    
    while (fgets(line, sizeof(line), f)) {
        char *key, *value, *eq, *end;
        
        /* Skip comments and empty lines */
        if (line[0] == '#' || line[0] == '\n' || line[0] == '\0') {
            continue;
        }
        
        /* Find '=' */
        eq = strchr(line, '=');
        if (!eq) continue;
        
        /* Extract key (before '=') */
        *eq = '\0';
        key = line;
        
        /* Trim spaces from key */
        while (*key == ' ' || *key == '\t') key++;
        end = key + strlen(key) - 1;
        while (end > key && (*end == ' ' || *end == '\t')) {
            *end = '\0';
            end--;
        }
        
        /* Extract value (after '=') */
        value = eq + 1;
        
        /* Trim leading spaces */
        while (*value == ' ' || *value == '\t') value++;
        
        /* Remove trailing newline and spaces */
        end = value + strlen(value) - 1;
        while (end >= value && (*end == '\n' || *end == '\r' || *end == ' ' || *end == '\t')) {
            *end = '\0';
            end--;
        }
        
        /* Remove quotes if present */
        if (*value == '"' || *value == '\'') {
            char quote = *value;
            value++;
            end = value + strlen(value) - 1;
            if (end >= value && *end == quote) {
                *end = '\0';
            }
        }
        
        /* Store in hash table */
        if (strlen(key) > 0) {
            g_hash_table_insert(config, g_strdup(key), g_strdup(value));
        }
    }
    
    fclose(f);
    return config;
}

/*
 * get_config_value()
 * Read a configuration value from /etc/default/jackd-rt
 */
gchar *get_config_value(const char *key) {
    GHashTable *config = parse_config_file(JACKD_RT_CONFIG);
    gchar *value = NULL;
    
    if (config) {
        const gchar *val = g_hash_table_lookup(config, key);
        if (val) {
            value = g_strdup(val);
        }
        g_hash_table_destroy(config);
    }
    
    return value;
}

/*
 * get_config_int()
 * Read an integer configuration value
 */
gint get_config_int(const char *key, gint default_value) {
    gchar *str_val = get_config_value(key);
    gint result = default_value;
    
    if (str_val) {
        result = atoi(str_val);
        g_free(str_val);
    }
    
    return result;
}

/*
 * set_config_value()
 * Write a configuration value to /etc/default/jackd-rt atomically
 * Preserves comments and other settings
 */
gboolean set_config_value(const char *key, const char *value) {
    FILE *in, *out;
    char line[MAX_LINE];
    char tmpfile[] = "/etc/default/jackd-rt.tmp.XXXXXX";
    int fd;
    gboolean key_found = FALSE;
    
    /* Create temporary file */
    fd = mkstemp(tmpfile);
    if (fd < 0) {
        g_critical("settings_sync: Failed to create temp file: %s", strerror(errno));
        return FALSE;
    }
    
    out = fdopen(fd, "w");
    if (!out) {
        g_critical("settings_sync: Failed to open temp file: %s", strerror(errno));
        close(fd);
        unlink(tmpfile);
        return FALSE;
    }
    
    /* Open original file */
    in = fopen(JACKD_RT_CONFIG, "r");
    if (!in) {
        /* File doesn't exist, create new one */
        fprintf(out, "# /etc/default/jackd-rt - JACK configuration\n");
        fprintf(out, "# Generated by jack-bridge D-Bus service\n\n");
        fprintf(out, "%s=%s\n", key, value);
        fclose(out);
        
        if (rename(tmpfile, JACKD_RT_CONFIG) != 0) {
            g_critical("settings_sync: Failed to rename %s: %s", tmpfile, strerror(errno));
            unlink(tmpfile);
            return FALSE;
        }
        
        return TRUE;
    }
    
    /* Copy file, replacing key if found */
    while (fgets(line, sizeof(line), in)) {
        char *eq = strchr(line, '=');
        
        /* Check if this line contains our key */
        if (eq) {
            char saved_eq = *eq;
            *eq = '\0';
            
            /* Trim spaces from line key */
            char *line_key = line;
            while (*line_key == ' ' || *line_key == '\t') line_key++;
            char *end = line_key + strlen(line_key) - 1;
            while (end > line_key && (*end == ' ' || *end == '\t')) {
                *end = '\0';
                end--;
            }
            
            if (strcmp(line_key, key) == 0) {
                /* Replace this line */
                fprintf(out, "%s=%s\n", key, value);
                key_found = TRUE;
                *eq = saved_eq; /* Restore for next iteration */
                continue;
            }
            
            *eq = saved_eq; /* Restore */
        }
        
        /* Copy line as-is */
        fputs(line, out);
    }
    
    /* If key wasn't found, append it */
    if (!key_found) {
        fprintf(out, "\n# Added by jack-bridge D-Bus service\n");
        fprintf(out, "%s=%s\n", key, value);
    }
    
    fclose(in);
    fclose(out);
    
    /* Atomic rename */
    if (rename(tmpfile, JACKD_RT_CONFIG) != 0) {
        g_critical("settings_sync: Failed to rename %s to %s: %s",
                   tmpfile, JACKD_RT_CONFIG, strerror(errno));
        unlink(tmpfile);
        return FALSE;
    }
    
    return TRUE;
}

/*
 * set_config_int()
 * Write an integer configuration value
 */
gboolean set_config_int(const char *key, gint value) {
    gchar *str_val = g_strdup_printf("%d", value);
    gboolean result = set_config_value(key, str_val);
    g_free(str_val);
    return result;
}

/*
 * validate_sample_rate()
 * Check if sample rate is valid
 */
gboolean validate_sample_rate(guint rate) {
    switch (rate) {
        case 22050:
        case 44100:
        case 48000:
        case 88200:
        case 96000:
        case 176400:
        case 192000:
            return TRUE;
        default:
            return FALSE;
    }
}

/*
 * validate_period()
 * Check if period (frames/buffer) is valid (must be power of 2)
 */
gboolean validate_period(guint period) {
    /* Must be power of 2 between 16 and 4096 */
    if (period < 16 || period > 4096) {
        return FALSE;
    }
    
    /* Check if power of 2: (n & (n-1)) == 0 */
    return (period & (period - 1)) == 0;
}

/*
 * validate_nperiods()
 * Check if nperiods is valid (must be >= 2)
 */
gboolean validate_nperiods(guint nperiods) {
    /* Minimum 2, maximum 8 (reasonable range) */
    return (nperiods >= 2 && nperiods <= 8);
}

/*
 * validate_priority()
 * Check if realtime priority is valid
 */
gboolean validate_priority(guint priority) {
    /* 0 = disabled, 10-89 = realtime range */
    return (priority == 0 || (priority >= 10 && priority <= 89));
}

/*
 * calculate_latency_ms()
 * Calculate theoretical latency in milliseconds
 */
gdouble calculate_latency_ms(guint period, guint nperiods, guint sample_rate) {
    if (sample_rate == 0) {
        return 0.0;
    }
    
    /* Latency = (period Ã— nperiods) / sample_rate * 1000 */
    return ((gdouble)(period * nperiods) / (gdouble)sample_rate) * 1000.0;
}