#!/bin/sh
### BEGIN INIT INFO
# Provides:          jackd-rt
# Required-Start:    $local_fs $remote_fs
# Required-Stop:     $local_fs $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start JACK (classic jackd) at boot with realtime tuning
# Description:       Starts jackd as a regular user (detected) using ALSA device auto-detection.
### END INIT INFO

# contrib/init.d/jackd-rt - SysV init script for jackd (classic) with auto-detection.
# Template is non-hardcoded; overrides may be placed in /etc/default/jackd-rt

. /lib/lsb/init-functions

# Load overrides if present
if [ -r /etc/default/jackd-rt ]; then
    . /etc/default/jackd-rt
fi

# Defaults (can be overridden by /etc/default/jackd-rt)
: ${JACKD_USER:=""}
: ${JACKD_DEVICE:=""}
: ${JACKD_SR:=48000}
: ${JACKD_PERIOD:=256}
: ${JACKD_NPERIODS:=3}
: ${JACKD_PRIORITY:=70}
: ${JACKD_MIDI:="seq"}
: ${JACKD_ARGS:=""}
: ${JACKD_DAEMON:=/usr/bin/jackd}
: ${DETECT_SCRIPT:=/usr/local/lib/jack-bridge/detect-alsa-device.sh}
: ${DETECT_USER_SCRIPT:=/usr/local/lib/jack-bridge/detect-user.sh}
: ${JACKD_LOG:=/var/log/jackd-rt.log}
: ${MONITOR_PIDFILE:=/var/run/jack-connection-monitor.pid}

# detect_user(): removed; detection is handled inline in start() for portability

# detect_device(): removed; device detection is handled inline in start()

start() {
    log_daemon_msg "Starting JACK (jackd) with realtime settings" "jackd-rt"
    
    # Check if already running
    if [ -f /var/run/jackd-rt.pid ]; then
        pid=$(cat /var/run/jackd-rt.pid 2>/dev/null || true)
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            log_progress_msg "already running"
            log_end_msg 0
            return 0
        fi
        # Stale pidfile
        rm -f /var/run/jackd-rt.pid 2>/dev/null || true
    fi

    # Wait for ALSA devices to appear
    # Cold boot: 2s (modern systems are fast), Restart: 0.5s (devices already present)
    WAIT_SECS=2
    waited=0
    
    # Check if this is likely a restart scenario (JACK was recently running)
    if [ -f /var/run/jackd-rt.pid.old ] || [ -f /var/run/jack-bridge-dbus.pid ]; then
        echo "jackd-rt: Detected restart scenario, using fast path"
        WAIT_SECS=1  # 1 second is plenty for restarts
    fi
    
    while [ $waited -lt $WAIT_SECS ]; do
        if [ -d /dev/snd ] && command -v aplay >/dev/null 2>&1 && aplay -l 2>/dev/null | grep -v -E 'Loopback|Loop Back' | sed -n '/card /p' >/dev/null 2>&1; then
            echo "jackd-rt: ALSA devices ready after ${waited}s"
            break
        fi
        sleep 1
        waited=$((waited+1))
    done

    # Best-effort: ensure ALSA Loopback (snd-aloop) is available for Gaming.
    # This avoids introducing a separate boot-time init ordering dependency
    # while still providing the Loopback card before JACK and bridge ports.
    if [ -r /proc/asound/cards ] && grep -q 'Loopback' /proc/asound/cards 2>/dev/null; then
        echo "jackd-rt: ALSA Loopback card already present"
    else
        # Try common modprobe paths explicitly; do not fail start if missing.
        if command -v modprobe >/dev/null 2>&1; then
            MODPROBE_CMD="modprobe"
        elif [ -x /sbin/modprobe ]; then
            MODPROBE_CMD="/sbin/modprobe"
        elif [ -x /usr/sbin/modprobe ]; then
            MODPROBE_CMD="/usr/sbin/modprobe"
        else
            MODPROBE_CMD=""
        fi

        if [ -n "$MODPROBE_CMD" ]; then
            if "$MODPROBE_CMD" snd-aloop 2>/dev/null; then
                echo "jackd-rt: Loaded snd-aloop via $MODPROBE_CMD"
                sleep 1
            else
                log_warning_msg "jackd-rt: $MODPROBE_CMD snd-aloop failed; Gaming Loopback card may be unavailable"
            fi
        else
            log_warning_msg "jackd-rt: modprobe not available; cannot auto-load snd-aloop for Gaming"
        fi
    fi

    # Inline: detect user to run under (no eval, fixed /bin/sh for helpers)
    USERNAME=""
    if [ -n "$JACKD_USER" ]; then
        USERNAME="$JACKD_USER"
    elif [ -x "$DETECT_USER_SCRIPT" ]; then
        USER_OUT="$(/bin/sh "$DETECT_USER_SCRIPT" 2>/dev/null || true)"
        [ -n "$USER_OUT" ] && USERNAME="$USER_OUT"
    fi
    if [ -z "$USERNAME" ]; then
        # first user with UID>=1000 and in audio group
        for user in $(cut -d: -f1 /etc/passwd); do
            uid=$(id -u "$user" 2>/dev/null || true)
            if [ -n "$uid" ] && [ "$uid" -ge 1000 ]; then
                groups=$(id -nG "$user" 2>/dev/null || true)
                if printf '%s\n' " $groups " | grep -q ' audio '; then
                    USERNAME="$user"; break
                fi
            fi
        done
    fi
    if [ -z "$USERNAME" ]; then
        # fallback to first UID>=1000 even if not in audio
        for user in $(cut -d: -f1 /etc/passwd); do
            uid=$(id -u "$user" 2>/dev/null || true)
            if [ -n "$uid" ] && [ "$uid" -ge 1000 ]; then
                USERNAME="$user"
                break
            fi
        done
    fi
    [ -z "$USERNAME" ] && USERNAME="root"

    # Inline: detect ALSA device
    DEVICE=""
    if [ -n "$JACKD_DEVICE" ]; then
        DEVICE="$JACKD_DEVICE"
    elif [ -x "$DETECT_SCRIPT" ]; then
        DEVICE_OUT="$(/bin/sh "$DETECT_SCRIPT" 2>/dev/null || true)"
        if [ -n "$DEVICE_OUT" ]; then
            DEVICE="$DEVICE_OUT"
        else
            log_warning_msg "jackd-rt: detector returned empty; using hw:0"
            DEVICE="hw:0"
        fi
    else
        DEVICE="hw:0"
    fi

    # Build jackd args with SEPARATE playback and capture devices
    # -P: Playback uses detected device (can be hw:CARD=PCH, hw:CARD=HDMI, etc)
    # -C: Capture ALWAYS uses hw:0 (provides baseline internal mic via system:capture)
    #     Additional capture sources (USB, etc) are spawned as alsa_in clients by jack-route-select
    if [ -n "$JACKD_MIDI" ] && [ "$JACKD_MIDI" != "none" ]; then
        ARGS="-R -P${JACKD_PRIORITY} -d alsa -P ${DEVICE} -C hw:0 -r ${JACKD_SR} -p ${JACKD_PERIOD} -n ${JACKD_NPERIODS} -X ${JACKD_MIDI} ${JACKD_ARGS}"
    else
        ARGS="-R -P${JACKD_PRIORITY} -d alsa -P ${DEVICE} -C hw:0 -r ${JACKD_SR} -p ${JACKD_PERIOD} -n ${JACKD_NPERIODS} ${JACKD_ARGS}"
    fi

    # Ensure user exists
    if ! id "$USERNAME" >/dev/null 2>&1; then
        log_failure_msg "User $USERNAME does not exist"
        return 1
    fi

    # Ensure jackd binary exists
    if [ ! -x "$JACKD_DAEMON" ]; then
        log_failure_msg "jackd not found at $JACKD_DAEMON"
        return 1
    fi

    # Prepare log file and permissions
    touch "$JACKD_LOG" 2>/dev/null || true
    chown "$USERNAME":"$USERNAME" "$JACKD_LOG" 2>/dev/null || true

    # Build command: start a login shell for $USERNAME via su so PAM limits apply, then exec jackd with logging
    # Export JACK_NO_AUDIO_RESERVATION so jackd skips session bus reservation when run as a system service
    CMD="exec su -l \"$USERNAME\" -s /bin/sh -c 'export JACK_NO_AUDIO_RESERVATION=1; exec ${JACKD_DAEMON} ${ARGS} >>\"$JACKD_LOG\" 2>&1'"

    # Start jackd as login user via start-stop-daemon (no --chuid; PID tracks exec chain)
    start-stop-daemon --start --background --make-pidfile --pidfile /var/run/jackd-rt.pid \
        --startas /bin/sh -- -c "$CMD" \
        || { log_failure_msg "Failed to start jackd"; log_end_msg 1; return 1; }

    # Health check: prefer jack_wait, fallback to pid check
    # Use realistic timeout: 3s for cold boot, 2s for restart scenarios
    JACK_WAIT_TIMEOUT=3  # 3 seconds is sufficient for cold boot on modern systems
    
    # Detect restart scenario for even faster response
    if [ -f /var/run/jackd-rt.pid.old ] || [ -f /var/run/jack-bridge-dbus.pid ]; then
        JACK_WAIT_TIMEOUT=2  # 2 seconds is plenty for restarts
    fi
    
    if command -v jack_wait >/dev/null 2>&1; then
        if ! jack_wait -w -t $JACK_WAIT_TIMEOUT >/dev/null 2>&1; then
            log_warning_msg "jackd did not become ready in ${JACK_WAIT_TIMEOUT}s; last 30 lines of $JACKD_LOG:"
            tail -n 30 "$JACKD_LOG" 2>/dev/null || true
            log_end_msg 1
            return 1
        fi

        # Autoconnect (if present) runs once at startup
        if [ -x /usr/local/lib/jack-bridge/jack-autoconnect ]; then
            /usr/local/lib/jack-bridge/jack-autoconnect >/dev/null 2>&1 || true
        fi
        
        # NOTE: jack-connection-manager is now started by separate init script
        # (contrib/init.d/jack-connection-manager) for cleaner service management
    else
        sleep 1
        if ! { [ -s /var/run/jackd-rt.pid ] && kill -0 "$(cat /var/run/jackd-rt.pid 2>/dev/null)" >/dev/null 2>&1; }; then
            log_warning_msg "jackd appears to have exited early; last 30 lines of $JACKD_LOG:"
            tail -n 30 "$JACKD_LOG" 2>/dev/null || true
            log_end_msg 1
            return 1
        fi
    fi

    log_end_msg 0
    return 0
}

stop() {
    log_daemon_msg "Stopping JACK (jackd)" "jackd-rt"
    
    # Check if actually running
    if [ ! -f /var/run/jackd-rt.pid ]; then
        log_progress_msg "not running"
        log_end_msg 0
        return 0
    fi
    
    pid=$(cat /var/run/jackd-rt.pid 2>/dev/null || true)
    if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
        log_progress_msg "not running"
        rm -f /var/run/jackd-rt.pid 2>/dev/null || true
        log_end_msg 0
        return 0
    fi
    
    # CRITICAL: Stop monitor FIRST to prevent reconnect attempts
    if [ -f "$MONITOR_PIDFILE" ]; then
        monitor_pid=$(cat "$MONITOR_PIDFILE" 2>/dev/null || true)
        if [ -n "$monitor_pid" ] && kill -0 "$monitor_pid" 2>/dev/null; then
            log_progress_msg "stopping monitor"
            kill -TERM "$monitor_pid" 2>/dev/null || true
            sleep 1
            kill -0 "$monitor_pid" 2>/dev/null && kill -KILL "$monitor_pid" 2>/dev/null || true
        fi
        rm -f "$MONITOR_PIDFILE" 2>/dev/null || true
    fi
    
    # Now stop JACK with proper retry strategy
    log_progress_msg "stopping jackd (pid $pid)"
    start-stop-daemon --stop --pidfile /var/run/jackd-rt.pid --retry=TERM/10/KILL/2 --oknodo
    STOP_STATUS=$?
    rm -f /var/run/jackd-rt.pid 2>/dev/null || true
    
    if [ $STOP_STATUS -eq 0 ]; then
        log_end_msg 0
        return 0
    else
        log_end_msg 1
        return 1
    fi
}

status() {
    if [ -f /var/run/jackd-rt.pid ]; then
        pid=$(cat /var/run/jackd-rt.pid 2>/dev/null)
        if [ -n "$pid" ] && kill -0 "$pid" >/dev/null 2>&1; then
            echo "jackd running (pid $pid)"
            return 0
        fi
    fi
    echo "jackd not running"
    return 1
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart|force-reload)
        stop
        sleep 1
        start
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 2
        ;;
esac

exit 0
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|status}"
        exit 2
        ;;
esac

exit 0
